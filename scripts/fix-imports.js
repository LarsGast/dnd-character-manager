// Usage:
//   node scripts/fix-imports.js [--fix] [--verbose]
// Description:
//   Scans repo for .js files, finds import / export-from / dynamic imports,
//   resolves relative and root-absolute specifiers, and reports missing targets.
//   If --fix is passed, and a single candidate file exists, the import is replaced.
// Notes:
//   Automatically generated by ChatGPT, might contain bugs. Use with caution.  

const fs = require('fs');
const path = require('path');

const args = process.argv.slice(2);
const doFix = args.includes('--fix');
const verbose = args.includes('--verbose');

const projectRoot = process.cwd();
const IGNORES = ['node_modules', '.git', '_site'];

function walk(dir) {
  const list = [];
  (function _walk(d) {
    const entries = fs.readdirSync(d, { withFileTypes: true });
    for (const e of entries) {
      if (IGNORES.includes(e.name)) continue;
      const full = path.join(d, e.name);
      if (e.isDirectory()) _walk(full);
      else if (e.isFile() && full.endsWith('.js')) list.push(full);
    }
  })(dir);
  return list;
}

function readBaseurl() {
  const cfg = path.join(projectRoot, '_config.yml');
  if (!fs.existsSync(cfg)) return '/';
  const txt = fs.readFileSync(cfg, 'utf8');
  const m = txt.match(/^\s*baseurl:\s*(.+)\s*$/m);
  if (!m) return '/';
  const v = m[1].trim();
  // remove surrounding quotes
  return v.replace(/^['"]|['"]$/g, '') || '/';
}

const baseurl = readBaseurl();
if (verbose) console.log('Detected baseurl from _config.yml:', baseurl);

const allJs = walk(path.join(projectRoot, 'build'));
if (allJs.length === 0) {
  console.error('No .js files found.');
  process.exit(1);
}

// helpers
function escapeRegExp(s) {
  return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}

function normalizePosix(p) {
  return p.split(path.sep).join('/');
}

// import finding regexes
const importFromRe = /import\s+[\s\S]*?\s+from\s+['"]([^'"]+)['"]/g;
const exportFromRe = /export\s+[\s\S]*?\s+from\s+['"]([^'"]+)['"]/g;
const dynamicImportRe = /import\s*\(\s*['"]([^'"]+)['"]\s*\)/g;

const results = [];
const filenameIndex = {}; // basename -> [fullPaths]
for (const f of allJs) {
  const b = path.basename(f);
  filenameIndex[b] = filenameIndex[b] || [];
  filenameIndex[b].push(f);
}

function tryResolveSpecifier(importingFile, spec) {
  // skip template/Liquid imports
  if (spec.includes('{{') || spec.includes('{%')) {
    return { type: 'liquid', ok: null };
  }
  // bare imports (packages) -> skip
  if (!spec.startsWith('.') && !spec.startsWith('/')) {
    return { type: 'bare', ok: null };
  }

  // resolve physical file path(s) to check existence
  let candidates = [];

  function pushIfExists(p) {
    try {
      if (fs.existsSync(p) && fs.statSync(p).isFile()) candidates.push(p);
    } catch (e) {}
  }

  function tryPaths(base) {
    // try as-is
    pushIfExists(base);
    // try adding .js
    pushIfExists(base + '.js');
    // try index.js in directory
    pushIfExists(path.join(base, 'index.js'));
  }

  if (spec.startsWith('.')) {
    const abs = path.resolve(path.dirname(importingFile), spec);
    tryPaths(abs);
  } else if (spec.startsWith('/')) {
    // spec is site-root absolute. Map to repo: strip leading '/', join to project root.
    const trimmed = spec.replace(/^\//, '');
    const abs = path.join(projectRoot, trimmed);
    tryPaths(abs);

    // If baseurl is set (e.g. "/repo") some imports may have been written with baseurl in mind.
    // Try removing baseurl prefix if present.
    if (baseurl && baseurl !== '/' && spec.startsWith(baseurl)) {
      const altTrim = spec.slice(baseurl.length).replace(/^\//, '');
      const altFull = path.join(projectRoot, altTrim);
      tryPaths(altFull);
    }
  }

  const ok = candidates.length > 0;
  return { type: spec.startsWith('/') ? 'root' : 'relative', ok, candidates };
}

function findFilenameCandidates(spec) {
  const base = path.basename(spec);
  // if exact name with extension:
  if (filenameIndex[base]) return filenameIndex[base];
  // try with .js added
  if (!base.endsWith('.js')) {
    if (filenameIndex[base + '.js']) return filenameIndex[base + '.js'];
  }
  // fallback: search for files ending with base
  const matches = allJs.filter(p => p.endsWith('/' + base) || p.endsWith('/' + base + '.js'));
  return matches;
}

// scan files
for (const file of allJs) {
  const text = fs.readFileSync(file, 'utf8');
  const specs = new Set();

  let m;
  while ((m = importFromRe.exec(text))) specs.add(m[1]);
  while ((m = exportFromRe.exec(text))) specs.add(m[1]);
  while ((m = dynamicImportRe.exec(text))) specs.add(m[1]);

  for (const spec of specs) {
    const res = tryResolveSpecifier(file, spec);
    if (res.type === 'bare' || res.type === 'liquid') {
      // don't attempt to resolve but report if liquid
      if (res.type === 'liquid') {
        results.push({ file, spec, status: 'liquid', candidates: [], message: 'Contains Liquid; Jekyll will render this' });
      }
      continue;
    }
    if (!res.ok) {
      // find candidate files by name
      const cand = findFilenameCandidates(spec);
      const candRel = cand.map(c => normalizePosix(path.relative(path.dirname(file), c)));
      results.push({ file, spec, status: 'missing', candidates: cand, relCandidates: candRel });
    } else {
      if (verbose) {
        results.push({ file, spec, status: 'ok', candidates: res.candidates });
      }
    }
  }
}

// output report
const missing = results.filter(r => r.status === 'missing');
const liquid = results.filter(r => r.status === 'liquid');

console.log('--- import-check report ---');
console.log('Scanned .js files:', allJs.length);
console.log('Missing imports found:', missing.length);
console.log('Liquid-containing imports skipped:', liquid.length);
console.log('');

if (liquid.length > 0) {
  console.log('Note: some imports contain Jekyll/Liquid expressions and cannot be statically checked:');
  for (const r of liquid) {
    console.log(`  ${path.relative(projectRoot, r.file)}  ->  "${r.spec}"`);
  }
  console.log('');
}

if (missing.length === 0) {
  console.log('No missing imports (static check) — nice!');
} else {
  console.log('Missing imports and suggested candidates:');
  for (const r of missing) {
    console.log(`\nFile: ${path.relative(projectRoot, r.file)}`);
    console.log(`  Specifier: "${r.spec}"`);
    if (r.candidates.length === 0) {
      console.log('  No filename matches found in repo for the imported basename.');
    } else {
      console.log('  Candidate file(s):');
      for (const c of r.candidates) {
        const rel = normalizePosix(path.relative(path.dirname(r.file), c));
        const suggestion = (rel.startsWith('.') ? rel : './' + rel);
        console.log(`    - ${path.relative(projectRoot, c)}  => suggested import: "${suggestion}"`);
      }
    }
  }

  // Auto-fix if requested
  if (doFix) {
    console.log('\n-- Running auto-fix (--fix) --');
    let fixes = 0;
    for (const r of missing) {
      if (r.candidates.length === 1) {
        const candidate = r.candidates[0];
        const relPath = normalizePosix(path.relative(path.dirname(r.file), candidate));
        const newSpec = relPath.startsWith('.') ? relPath : './' + relPath;
        // read file, do safe replacement only for import/export/dynamic import occurrences containing the exact spec
        let content = fs.readFileSync(r.file, 'utf8');
        const oldSpecEsc = escapeRegExp(r.spec);

        const importRegex = new RegExp(`(import[\\s\\S]*?from\\s*)(['"])\s*${oldSpecEsc}\s*\\2`, 'g');
        const exportRegex = new RegExp(`(export[\\s\\S]*?from\\s*)(['"])\s*${oldSpecEsc}\s*\\2`, 'g');
        const dynRegex = new RegExp(`(import\\s*\\(\\s*)(['"])${oldSpecEsc}\\2(\\s*\\))`, 'g');

        let replaced = false;
        content = content.replace(importRegex, (m, p, q) => { replaced = true; return p + q + newSpec + q; });
        content = content.replace(exportRegex, (m, p, q) => { replaced = true; return p + q + newSpec + q; });
        content = content.replace(dynRegex, (m, p, q, s) => { replaced = true; return p + q + newSpec + q + s; });

        if (replaced) {
          fs.writeFileSync(r.file, content, 'utf8');
          fixes++;
          console.log(`Fixed ${path.relative(projectRoot, r.file)}  -> replaced "${r.spec}" with "${newSpec}"`);
        } else {
          console.log(`Could not safely replace in ${path.relative(projectRoot, r.file)} (pattern not found), manual fix needed.`);
        }
      } else {
        console.log(`Skipping auto-fix for ${path.relative(projectRoot, r.file)} — ${r.candidates.length} candidate files found (manual resolution required).`);
      }
    }
    console.log(`\nAuto-fix completed, files changed: ${fixes}`);
  } else {
    console.log('\nRun node scripts/check-imports.js --fix to automatically rewrite imports when there is exactly one candidate match (backups created).');
  }
}

console.log('\n--- end report ---');
